.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.35
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Algorithm::Viterbi 3"
.TH Algorithm::Viterbi 3 "2006-11-21" "perl v5.8.9" "User Contributed Perl Documentation"
.SH "NAME"
Algorithm::Viterbi \- Compute Viterbi path and probability 
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Algorithm::Viterbi;
.Ve
.PP
.Vb 1
\&  my $start_probability = { 'Rainy'=> 0.6, 'Sunny'=> 0.4 };
.Ve
.PP
.Vb 4
\&  my $transition_probability = {
\&   'Rainy' => {'Rainy'=> 0.7, 'Sunny'=> 0.3},
\&   'Sunny' => {'Rainy'=> 0.4, 'Sunny'=> 0.6},
\&  };
.Ve
.PP
.Vb 5
\&  my $emission = {
\&    'shop' =>  { 'Sunny' => '0.3', 'Rainy' => '0.4' },
\&    'walk' =>  { 'Sunny' => '0.6', 'Rainy' => '0.1' },
\&    'clean' => { 'Sunny' => '0.1', 'Rainy' => '0.5' }
\&  };
.Ve
.PP
.Vb 4
\&  my $v = Algorithm::Viterbi->new();
\&  $v->start($start_probability);
\&  $v->transition($transition_probability);
\&  $v->emission($emission_probability);
.Ve
.PP
.Vb 1
\&  my $observations = [ 'walk', 'shop', 'clean' ];
.Ve
.PP
.Vb 1
\&  my ($prob, $v_path, $v_prob) = $v->forward_viterbi($observations);
.Ve
.PP
.Vb 1
\&  -- or --
.Ve
.PP
.Vb 9
\&  my $training_data = [
\&    [ 'walk', 'Sunny' ],
\&    [ 'walk', 'Sunny' ],
\&    [ 'walk', 'Rainy' ],
\&    [ 'shop', 'Rainy' ],
\&    [ 'clean', 'Rainy' ],
\&    [ 'clean', 'Rainy' ],
\&    ...
\&  ];
.Ve
.PP
.Vb 2
\&  $v->train($training_data);
\&  my ($prob, $v_path, $v_prob) = $v->forward_viterbi($observations);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Algorithm::Viterbi computes the forward probability, the Viterbi path
and the Viterbi probability of a sequence of observations, based on 
a given start, emission and transition probability.
Alternatively, the start, emission and transition probability can be 
computed from a set of training data.
.PP
The whole idea of this module is inspired by an article on the Viterbi 
algorithm in Wikipedia, the free encyclopedia. Rather than copying all 
text, I'm just including the link to the Wikipedia page: 
<http://en.wikipedia.org/wiki/Viterbi_algorithm>.
I think the page is well-written and I see no need to repeat the theory 
here. Reading it may clarify the documentation below.
.SH "METHODS"
.IX Header "METHODS"
.IP "new" 8
.IX Item "new"
Creates a new \f(CW\*(C`Algorithm::Viterbi\*(C'\fR object. 
The following attributes can be set with the constructor:
.Sp
.Vb 4
\&  my $v = Algorthm::Viterbi->new(
\&    start_state => '$',
\&    unknown_emission_prob => undef,
\&    unknown_transition_prob => 0);
.Ve
.Sp
The values of the attributes in the example are the default values.
For a detailed description and use of these attributes, see below.
.IP "train" 8
.IX Item "train"
This method computes the start, emission and transition probabilities 
from a set of observations and their associated states.
The probabilities are simple averages of the passed observations,
so if you require sophisticated smoothing on the emission, start and/or
transition, then you're better off rolling your own.
.Sp
The value of member start_state is a bogus state used to define the begin state of the first transition.
By default, this state is set to '$'. You can change this by setting the variable in the constructor
or later by accessing the member directly. See example below.
.Sp
This state can also be used as a separator between the beginning and end of a sequence of observations. 
For example, you could assign this state (tag) to every end-of-sentence symbol when training on a 
pre-tagged corpus.
.Sp
The set of observations is passed as a reference to an array as shown in the following example:
.Sp
.Vb 3
\&  use strict;
\&  use Algorithm::Viterbi;
\&  use Data::Dumper;
.Ve
.Sp
.Vb 8
\&  my $observations = [
\&    [ 'work', 'rainy' ],
\&    [ 'work', 'sunny' ],
\&    [ 'walk', 'sunny' ],
\&    [ 'walk', 'rainy' ],
\&    [ 'shop', 'rainy' ],
\&    [ 'work', 'rainy' ],
\&  ];
.Ve
.Sp
.Vb 2
\&  my $v = Algorithm::Viterbi->new(start_state => '###');
\&  $v->train($observations);
.Ve
.Sp
.Vb 1
\&  print Dumper($v);
.Ve
.Sp
will produce:
.Sp
.Vb 38
\&  $VAR1 = bless( {
\&                 'transition' => {
\&                                   'sunny' => {
\&                                                'sunny' => '0.5',
\&                                                'rainy' => '0.25'
\&                                              },
\&                                   'rainy' => {
\&                                                'sunny' => '0.5',
\&                                                'rainy' => '0.5'
\&                                              },
\&                                   '###' => {
\&                                              'rainy' => '0.25'
\&                                            }
\&                                 },
\&                 'emission' => {
\&                                 'shop' => {
\&                                             'rainy' => '0.25'
\&                                           },
\&                                 'walk' => {
\&                                             'sunny' => '0.5',
\&                                             'rainy' => '0.25'
\&                                           },
\&                                 'work' => {
\&                                             'sunny' => '0.5',
\&                                             'rainy' => '0.5'
\&                                           }
\&                               },
\&                 'start_state' => '###',
\&                 'states' => [
\&                               'sunny',
\&                               'rainy'
\&                             ],
\&                 'unknown_transition_prob' => 0,
\&                 'start' => {
\&                              'sunny' => '0.333333333333333',
\&                              'rainy' => '0.666666666666667'
\&                            }
\&               }, 'Algorithm::Viterbi' );
.Ve
.IP "start" 8
.IX Item "start"
Initializes the start probabilities. 
The start probabilities are passed as a reference to a hash, as shown in
this example:
.Sp
.Vb 3
\&  my $start_probability = { 'Rainy'=> 0.6, 'Sunny'=> 0.4 };
\&  my $v = Algorithm::Viterbi->new();
\&  $v->start($start_probability);
.Ve
.Sp
From the start probabilities, all possible states are derived, by 
copying the keys of the start hash. This list of states is used by the 
forward_viterbi method. It is therefore important to mention all 
possible states in the start hash.
.Sp
Returns the start probabilities.
.IP "emission" 8
.IX Item "emission"
Initializes the emission probabilities. 
The emission is passed as a reference to a hash, as shown in
this example:
.Sp
.Vb 8
\&  my $emission_probability = {
\&          'shop' =>  { 'Sunny' => '0.3', 'Rainy' => '0.4' },
\&          'swim' =>  { 'Sunny' => '0.1' }, 
\&          'walk' =>  { 'Sunny' => '0.5', 'Rainy' => '0.1' },
\&          'clean' => { 'Sunny' => '0.1', 'Rainy' => '0.5' }
\&        };
\&  my $v = Algorithm::Viterbi->new();
\&  $v->emission($emission_probability);
.Ve
.Sp
The keys of the emission hash constitute the dictionary, which is used to determine 
whether an observation is a known or an unknown observation.
.Sp
Returns the emission probabilities.
.IP "transition" 8
.IX Item "transition"
Initializes the transition probabilities. 
The transition is passed as a reference to a hash, as shown in
this example:
.Sp
.Vb 6
\&  my $transition_probability = {
\&   'Rainy' => {'Rainy'=> 0.7, 'Sunny'=> 0.3},
\&   'Sunny' => {'Rainy'=> 0.4, 'Sunny'=> 0.6},
\&  };
\&  my $v = Algorithm::Viterbi->new();
\&  $v->transition($transition_probability);
.Ve
.Sp
The transition hash can be 'sparse': it is sufficient to include only known 
transitions between states. See method get_transition.
.Sp
Returns the transition probabilities.
.IP "forward_viterbi" 8
.IX Item "forward_viterbi"
This method calculates the forward probability, the Viterbi path 
and the Viterbi probability of a given sequence of observations.
For a detailed description of the Algorithm, see the Wikipedia page
<http://en.wikipedia.org/wiki/Viterbi_algorithm>.
.Sp
The difference with the algorithm described in the web page above, 
is that the emission and the transition are calculated somewhat
differently. See methods get_emission and get_transition.
.Sp
Example:
.Sp
.Vb 3
\&  use strict;
\&  use Algorithm::Viterbi;
\&  use Data::Dumper;
.Ve
.Sp
.Vb 6
\&  my $observations = [ 'walk', 'shop', 'clean' ];
\&   my $start = { 'Rainy'=> 0.6, 'Sunny'=> 0.4 };
\&   my $transition = {
\&      'Rainy' => {'Rainy'=> 0.7, 'Sunny'=> 0.3},
\&      'Sunny' => {'Rainy'=> 0.4, 'Sunny'=> 0.6},
\&      };
.Ve
.Sp
.Vb 5
\&  my $emission = {
\&    'shop' => {
\&      'Sunny' => '0.3',
\&      'Rainy' => '0.4',
\&    },
.Ve
.Sp
.Vb 9
\&    'walk' => {
\&      'Sunny' => '0.6',
\&      'Rainy' => '0.1'
\&    },
\&    'clean' => {
\&      'Sunny' => '0.1',
\&      'Rainy' => '0.5'
\&      }
\&  };
.Ve
.Sp
.Vb 4
\&  my $v = Algorithm::Viterbi->new();
\&  $v->emission($emission);
\&  $v->transition($transition);
\&  $v->start($start);
.Ve
.Sp
.Vb 1
\&  print Dumper ($v->forward_viterbi($observations));
.Ve
.Sp
produces:
.Sp
.Vb 8
\&  $VAR1 = '0.033612';
\&  $VAR2 = [
\&            'Sunny',
\&            'Rainy',
\&            'Rainy',
\&            'Rainy'
\&          ];
\&  $VAR3 = '0.009408';
.Ve
.IP "get_emission" 8
.IX Item "get_emission"
Usage: \f(CW$v\fR\->get_emission($observation, \f(CW$state\fR);
.Sp
Returns the emission probability for a given observation and state.
This method is primarily for internal usage and is called
by the forward_viterbi method.
.Sp
The dictionary consists of the keys of the emission table, e.g. a list 
of known observations.
.Sp
If \f(CW$observation\fR is a known observation in the dictionary and \f(CW$state\fR
exists as a state for the observation in the emission table, then return 
the probability associated with \f(CW$observation\fR and \f(CW$state\fR.
.Sp
If the observation exists in the dictionary, but \f(CW$state\fR is a state not 
connected to the observation, then return 0.
.Sp
If the observation does not exist in the dictionary and \f(CW$v\fR\->{unknown_emission_prob}
is defined, then return \f(CW$v\fR\->{unknown_emission_prob}.
Setting \f(CW$v\fR\->{unknown_emission_prob} = 1 actually means that you are returning all
possible states for an unknown observation.
.Sp
If the observation is unknown in the dictionary and \f(CW$v\fR\->{unknown_emission_prob}
is not defined, then return the start probability of \f(CW$state\fR.
.Sp
Example:
.Sp
.Vb 17
\&  my $emission = {
\&    'shop' => {
\&                'Sunny' => '0.3',
\&                'Rainy' => '0.4'
\&              },
\&    'swim' => {
\&                'Sunny' => '0.1'
\&              },
\&    'walk' => {
\&                'Sunny' => '0.5',
\&                'Rainy' => '0.1'
\&              },
\&    'clean' => {
\&                 'Sunny' => '0.1',
\&                 'Rainy' => '0.5'
\&               }
\&  };
.Ve
.Sp
.Vb 1
\&  my $start = { 'Rainy'=> 0.6, 'Sunny'=> 0.4 };
.Ve
.Sp
.Vb 9
\&  my $v = Algorithm::Viterbi->new();
\&  $v->emission($emission);
\&  $v->start($start);
\&  my $e;
\&  $e = get_emission('shop', 'Rainy'); # $e = 0.4
\&  $e = get_emission('swim', 'Rainy'); # $e = 0
\&  $e = get_emission('hack', 'Rainy'); # $e = 0.6
\&  $v->{unknown_emission_prob} = 1;
\&  $e = get_emission('hack', 'Rainy'); # $e = 1
.Ve
.IP "get_transition" 8
.IX Item "get_transition"
Usage: \f(CW$v\fR\->get_transition($state, \f(CW$next_state\fR);
.Sp
Returns the transition probability between a state and the next state.
This method is primarily for internal usage and is called
by the forward_viterbi method.
.Sp
If the transition between \f(CW$state\fR and \f(CW$next_state\fR is defined, then return
the probability associated with it.
.Sp
If the transition between \f(CW$state\fR and \f(CW$next_state\fR does not exist, then return
the value of \f(CW$v\fR\->unknown_transition_prob, which will be 0 unless otherwise defined.
Setting this attribute to a very small value allows you to still obtain a Viterbi path, 
although no suitable transitions were found between states of a given observation.
.Sp
Example:
.Sp
.Vb 1
\&    use Algorithm::Viterbi;
.Ve
.Sp
.Vb 1
\&    my $observations = [ 'walk', 'shop', 'read' ];
.Ve
.Sp
.Vb 1
\&    my $start = { 'Rainy'=> 0.5, 'Sunny'=> 0.4, 'Stormy'=> 0.1 };
.Ve
.Sp
.Vb 4
\&    my $transition = {
\&       'Rainy' => {'Rainy'=> 0.7, 'Sunny'=> 0.3},
\&       'Sunny' => {'Rainy'=> 0.4, 'Sunny'=> 0.5, 'Stormy'=>.1},
\&       };
.Ve
.Sp
.Vb 13
\&    my $emission = {
\&      'shop' => {
\&                  'Sunny' => '0.4',
\&                  'Rainy' => '0.9'
\&                },
\&      'read' => {
\&                  'Stormy' => '1'
\&                },
\&      'walk' => {
\&                  'Sunny' => '0.6',
\&                  'Rainy' => '0.1'
\&                },
\&    };
.Ve
.Sp
.Vb 4
\&    my $v = Algorithm::Viterbi->new();
\&    $v->emission($emission);
\&    $v->transition($transition);
\&    $v->start($start);
.Ve
.Sp
.Vb 2
\&    my ($prob, $v_path, $v_prob) = $v->forward_viterbi($observations); 
\&      # returns 0, [], 0
.Ve
.Sp
.Vb 1
\&    $v->{unknown_transition_prob} = 1e-100;
.Ve
.Sp
.Vb 2
\&    ($prob, $v_path, $v_prob) = $v->forward_viterbi($observations); 
\&      # returns 1.62e-102, ['Sunny', 'Sunny', 'Stormy', 'Stormy' ], 4.8e-103;
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Koen Dejonghe 	koen@fietsoverland.com
Copyright (c) 2006 Koen Dejonghe. All rights reserved.
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "VERSION"
.IX Header "VERSION"
Version 0.01 (2006\-Nov\-07)
